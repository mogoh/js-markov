class s extends class{random(s,t){if(Array.isArray(s)&&"array"===t){return s[Math.floor(Math.random()*s.length)]}if("object"==typeof s&&"object"===t){const t=Object.keys(s);return t[Math.floor(Math.random()*t.length)]}throw new Error("TODO")}}{constructor(){super(...arguments),this.states=[],this.start=[],this.order=3,this.possibilities={}}clearPossibilities(){this.possibilities={}}getPossibilities(s){if(void 0!==this.possibilities[s])return this.possibilities[s];throw new Error(`There is no such possibility called ${s}`)}getOrder(){return this.order}setOrder(s=3){s<=0&&console.error("Markov.setOrder: Order is not a positive number. Defaulting to 3."),this.order=s}addStates(s){Array.isArray(s)?this.states=s:this.states.push(s)}clearChain(){this.states=[],this.start=[],this.possibilities={},this.order=3}clearState(){this.states=[],this.start=[]}train(){this.clearPossibilities();for(let s=0;s<this.states.length;s++){this.start.push(this.states[s].substring(0,this.order));for(let t=0;t<=this.states[s].length-this.order;t++){const i=this.states[s].substring(t,t+this.order);this.possibilities[i]||(this.possibilities[i]=[]),this.possibilities[i].push(this.states[s].charAt(t+this.order))}}}generateRandom(s=15){const t=this.random(this.start,"array");let i=t,r=t,e="";for(let t=0;t<s-this.order&&(e=this.random(this.possibilities[r],"array"),e);t++)i+=e,r=i.substring(i.length-this.order,i.length);return i}}export{s as MarkovString};